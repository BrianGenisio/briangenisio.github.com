---
title: Testing WCF Service Apps (part 4 of 4)
id: 54
categories:
  - Uncategorized
date: 2009-01-05 17:39:00
tags:
---

Previous Posts:    
[Part 0 of 4: Introduction](http://houseofbilz.com/HouseOfBilz/archive/2008/11/18/testing-wcf-service-apps-part-0-of-4.aspx)     
[Part 1 of 4: Testing the Service](http://houseofbilz.com/archive/2008/11/24/testing-wcf-service-apps-part-1-of-4.aspx)     
[Part 2 of 4: Testing the Client](http://www.houseofbilz.com/archive/2008/11/29/testing-wcf-service-apps-part-2-of-4.aspx)     
[Part 3 of 4: Testing the Asynchronous Client](http://www.houseofbilz.com/archive/2008/12/19/testing-wcf-service-apps-part-3-of-4.aspx) 
 [![Shout it](http://dotnetshoutout.com/image.axd?url=http%3A%2F%2Fhouseofbilz.com%2FHouseOfBilz%2Farchive%2F2008%2F11%2F18%2Ftesting-wcf-service-apps-part-0-of-4.aspx)](http://dotnetshoutout.com/Testing-WCF-Services)   

### Functional Testing the WCF Application

In functional testing, the goal is to test as much of the application that you can to determine that it does what you want from a functional perspective.&#160; It differs greatly from unit testing in that a unit test is only concerned with an individual class.&#160; Functional tests are concerned with testing the interactions of the objects in the system from the user input to the user output.

I thought it would be easiest to draw out what the data mining application is doing in terms of data flow.&#160; This particular application is a data mining application which queries a service to pull out data that the user wants.&#160; In this case, the question that the user wants answered is &quot;What recipes exist in the database that include a given ingredient?&quot;&#160; The data flow goes like this:

[![App.Diagram](http://geekswithblogs.net/images/geekswithblogs_net/HouseOfBilz/WindowsLiveWriter/a0b52042f47e_BD87/App.Diagram_thumb.png)](http://geekswithblogs.net/images/geekswithblogs_net/HouseOfBilz/WindowsLiveWriter/a0b52042f47e_BD87/App.Diagram_2.png) 

The user types an ingredient into the console.&#160; The console launches our application and calls &quot;**Main**&quot; with the arguments that include the ingredient in question.&#160; The &quot;**Main**&quot; routine creates an **IngredientFinder** object which requests a list of all recipes known to the service.&#160; It does this by asking the service proxy which uses WCF to ask the actual **RecipeService**, which may exist anywhere on the planet.&#160; The actual **RecipeService** asks the **Business Objects** which in turn queries the database for all known recipes.&#160; The database returns the results to the **Business Objects** which in turn returns the results to the **RecipeService**.&#160; Those results travel through the WCF infrastructure back to the service proxy in the client.&#160; The **IngredientFinder** filters the recipes for the requested ingredient and returns the results to the &quot;**Main**&quot; method which then writes the results back to the console for the user to read.

From a testing perspective, the only code we are responsible for in this system is **Main, IngredientFinder, RecipeService** and **Business Objects**.&#160; The user and console are completely external to our application.&#160; The service proxy is auto-generated by Visual Studio and the WCF framework is part of the .NET framework.&#160; We do not need to test these parts.&#160; Finally, the database is also a Microsoft product (SQL Server) and we can trust that it works correctly as well.&#160; We need to eliminate all components in this system that we do not control, thus focus on testing the code in which we do control.

### Eliminating the User and Console

Traditionally our &quot;**Main**&quot; method would instantiate our IngredientFinder (see part 1) with the service proxy, get the result and write it out to the console:
  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E6:34ddc18b-05e4-4ee0-8677-1d54c16aba48" class="wlWriterEditableSmartContent"><pre style="background-color:#E4E4E4;overflow: auto;"><span style="color: #0000FF;">static</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> Main(</span><span style="color: #0000FF;">string</span><span style="color: #000000;">[] args)
{
    var finder </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> IngredientFinder(</span><span style="color: #0000FF;">new</span><span style="color: #000000;"> RecipeBoxServiceClient());

    </span><span style="color: #0000FF;">foreach</span><span style="color: #000000;"> (RecipeData recipe </span><span style="color: #0000FF;">in</span><span style="color: #000000;"> finder.GetRecipes(args[</span><span style="color: #800080;">0</span><span style="color: #000000;">]))
        Console.WriteLine(recipe.Title);

    Console.ReadKey();
}</span></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>

The problem with this is that **Console** is a static class and cannot be replaced as-is.&#160; Instead, we need to extract this as an interface and pass the interface in:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E6:b9c0323a-cda8-45b2-a2a8-4d6a6f650351" class="wlWriterEditableSmartContent"><pre style="background-color:#E4E4E4;overflow: auto;"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">interface</span><span style="color: #000000;"> IConsoleOutput
{
    </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> WriteLine(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> line);
    ConsoleKeyInfo ReadKey();
}

</span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> ConsoleOutput : IConsoleOutput
{
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> WriteLine(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> line) { Console.WriteLine(line); }
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ConsoleKeyInfo ReadKey() { </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> Console.ReadKey(); }
}</span></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>

By doing this, we can now replace the **Console.WriteLine** static method with a spy in our test (later).&#160; We will create a new static method named **Execute** which passes in the **IConsoleOutput** and **IRecipeBoxService** interfaces. Our new &quot;**Main**&quot; routine will look like this:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E6:e44be4f5-77c7-4229-ba51-42ed84bb231b" class="wlWriterEditableSmartContent"><pre style="background-color:#E4E4E4;overflow: auto;"><span style="color: #0000FF;">static</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> Main(</span><span style="color: #0000FF;">string</span><span style="color: #000000;">[] args)
{
    Execute(</span><span style="color: #0000FF;">new</span><span style="color: #000000;"> ConsoleOutput(), </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> RecipeBoxServiceClient(), args);
}

</span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">static</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> Execute(IConsoleOutput console, IRecipeBoxService service, </span><span style="color: #0000FF;">string</span><span style="color: #000000;">[] args)
{
    var finder </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> IngredientFinder(service);

    </span><span style="color: #0000FF;">foreach</span><span style="color: #000000;"> (RecipeData recipe </span><span style="color: #0000FF;">in</span><span style="color: #000000;"> finder.GetRecipes(args[</span><span style="color: #800080;">0</span><span style="color: #000000;">]))
        console.WriteLine(recipe.Title);

    console.ReadKey();
}</span></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>

### Eliminating the WCF Infrastructure

Now that the user and console have been abstracted out, we can start thinking about testing the **Execute** method.&#160; The problem we have now is that **IRecipeBoxService** is an automatically generated interface within the client's namespace.&#160; We have an implementation of this interface in the service, but it is defined in the service's namespace.&#160; The two interfaces are not compatible.&#160; We want to eliminate the need for WCF, so we cannot use the generated proxy class.&#160; What we need here is a bridge class:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E6:a328000e-4801-40d1-99af-8328cae6b68c" class="wlWriterEditableSmartContent"><pre style="background-color:#E4E4E4;overflow: auto;"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> ServiceWrapper : DataMining.RecipeBoxService.IRecipeBoxService
{
    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">readonly</span><span style="color: #000000;"> Services.IRecipeBoxService _source;

    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ServiceWrapper(Services.IRecipeBoxService source)
    {
        _source </span><span style="color: #000000;">=</span><span style="color: #000000;"> source;
    }

    </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">static</span><span style="color: #000000;"> ToType TranslateData</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">FromType, ToType</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">(FromType source) </span><span style="color: #0000FF;">where</span><span style="color: #000000;"> ToType : </span><span style="color: #0000FF;">class</span><span style="color: #000000;">
    {
        var serverSerializer </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> DataContractSerializer(</span><span style="color: #0000FF;">typeof</span><span style="color: #000000;">(FromType));
        var clientSerializer </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> DataContractSerializer(</span><span style="color: #0000FF;">typeof</span><span style="color: #000000;">(ToType));

        </span><span style="color: #0000FF;">using</span><span style="color: #000000;"> (var stream </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> MemoryStream())
        {
            serverSerializer.WriteObject(stream, source);
            stream.Flush();
            stream.Position </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">;

            </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> clientSerializer.ReadObject(stream) </span><span style="color: #0000FF;">as</span><span style="color: #000000;"> ToType;
        }
    }

    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> DataMining.RecipeBoxService.RecipeData[] AllRecipes()
    {
        var result </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> List</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">DataMining.RecipeBoxService.RecipeData</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">();
        </span><span style="color: #0000FF;">foreach</span><span style="color: #000000;"> (var data </span><span style="color: #0000FF;">in</span><span style="color: #000000;"> _source.AllRecipes())
            result.Add(TranslateData</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">Services.DataContracts.RecipeData, DataMining.RecipeBoxService.RecipeData</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">(data));
        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> result.ToArray();
    }

    ...
}</span></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>

This class bridges the client interface over to the service interface.&#160; WCF interfaces are made up of Service Contracts and Data Contracts.&#160; The Service Contract is the functional interface where the Data Contract defines what the data looks like.&#160; The WCF framework uses the **System.Runtime.Serialization.DataContractSerializer** to transfer the data in plain-text.&#160; In this **ServiceWrapper** class, the **TranslateData** function uses the **DataContractSerializer** to serialize the data to and from the client and service data types.&#160; This class is the glue that replaces WCF from the testing process.&#160; In a sense, this class is a very simple implementation of the WCF concepts.

### Putting it all Together

The only piece of functionality still out of our control is the database.&#160; I am going to replace the SQL Server with a temporal, in-memory database for testing.&#160; This post will not go into the details, but my previous post on Blah Blah Blah talks about how to do this.&#160; Now, our diagram looks shows a system where every piece of code is in our control:

[![App.Testing](http://geekswithblogs.net/images/geekswithblogs_net/HouseOfBilz/WindowsLiveWriter/a0b52042f47e_BD87/App.Testing_thumb.png)](http://geekswithblogs.net/images/geekswithblogs_net/HouseOfBilz/WindowsLiveWriter/a0b52042f47e_BD87/App.Testing_2.png) 

### **Writing our Functional Tests**

The only code we still need before we start writing functional tests is the **ConsoleOutputSpy**.&#160; It captures the output in a list of strings that we can verify against.

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E6:33ae001e-174b-47fb-962c-11f3b9ffca43" class="wlWriterEditableSmartContent"><pre style="background-color:#E4E4E4;overflow: auto;"><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> ConsoleOutputSpy : Program.IConsoleOutput
{
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> Output { </span><span style="color: #0000FF;">get</span><span style="color: #000000;">; </span><span style="color: #0000FF;">private</span><span style="color: #000000;"> </span><span style="color: #0000FF;">set</span><span style="color: #000000;">; }

    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ConsoleOutputSpy()          { Output </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> List</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">string</span><span style="color: #000000;">&gt;</span><span style="color: #000000;">(); }
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> WriteLine(</span><span style="color: #0000FF;">string</span><span style="color: #000000;"> line) { Output.Add(line); }
    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> ConsoleKeyInfo ReadKey()    { </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> ConsoleKeyInfo(); }
}</span></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>

Now that we have our console output spy, we can look at our test **SetUp**:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E6:bb5cedd5-0b32-4f1a-b20e-5f53895b4aa9" class="wlWriterEditableSmartContent"><pre style="background-color:#E4E4E4;overflow: auto;"><span style="color: #0000FF;">private</span><span style="color: #000000;"> ConsoleOutputSpy _consoleOutput;
</span><span style="color: #0000FF;">private</span><span style="color: #000000;"> DataMining.RecipeBoxService.IRecipeBoxService _service;

[SetUp]
</span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> SetUp()
{
    _service </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> ServiceWrapper(</span><span style="color: #0000FF;">new</span><span style="color: #000000;"> RecipeBoxService(</span><span style="color: #0000FF;">new</span><span style="color: #000000;"> MockBackEndConfiguration()));
    _consoleOutput </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> ConsoleOutputSpy();
}</span></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>

Finally, we can write our tests.&#160; This test will populate the mock database with four ingredients and three recipes.&#160; Only two of the recipes include the &quot;Cheese&quot; ingredient, so we can test that our data miner will return only those two recipes that contain &quot;Cheese&quot;:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:57F11A72-B0E5-49c7-9094-E3A15BD5B5E6:0f75cc33-24b2-4ae1-bc2f-7b8af140daed" class="wlWriterEditableSmartContent"><pre style="background-color:#E4E4E4;overflow: auto;"><span style="color: #000000;">[Test]
</span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> SimpleTest()
{
    AddIngredients(</span><span style="color: #800000;">"</span><span style="color: #800000;">Macaroni</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Cheese</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Bread</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Peanut Butter</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    AddRecipeToDatabase(</span><span style="color: #800000;">"</span><span style="color: #800000;">Mac &amp; Cheese</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Macaroni</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Cheese</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    AddRecipeToDatabase(</span><span style="color: #800000;">"</span><span style="color: #800000;">Grilled Cheese</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Bread</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Cheese</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    AddRecipeToDatabase(</span><span style="color: #800000;">"</span><span style="color: #800000;">Peanut Butter Sandwich</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Bread</span><span style="color: #800000;">"</span><span style="color: #000000;">, </span><span style="color: #800000;">"</span><span style="color: #800000;">Peanut Butter</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    Program.Execute(_consoleOutput, _service, </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> [] {</span><span style="color: #800000;">"</span><span style="color: #800000;">Cheese</span><span style="color: #800000;">"</span><span style="color: #000000;">});

    Assert.That(_consoleOutput.Output.Count, Is.EqualTo(</span><span style="color: #800080;">2</span><span style="color: #000000;">));
    Assert.That(_consoleOutput.Output[</span><span style="color: #800080;">0</span><span style="color: #000000;">], Is.EqualTo(</span><span style="color: #800000;">"</span><span style="color: #800000;">Mac &amp; Cheese</span><span style="color: #800000;">"</span><span style="color: #000000;">));
    Assert.That(_consoleOutput.Output[</span><span style="color: #800080;">1</span><span style="color: #000000;">], Is.EqualTo(</span><span style="color: #800000;">"</span><span style="color: #800000;">Grilled Cheese</span><span style="color: #800000;">"</span><span style="color: #000000;">));
}</span></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div>

### **Conclusion**

This concludes my four-part series on testing WCF applications.&#160; I have covered unit testing the service, unit testing the client, unit testing an asynchronous client and finally, functional testing the entire application.&#160; 

It is important for me to note that these techniques have served me very well in the real-world.&#160; I have a Silverlight application which communicates asynchronously with a back-end WCF service.&#160; These techniques have allowed us to write tests that cover our application from all aspects.&#160; The tests we have in place run extremely quickly and are robust because they do not rely on any services running on a separate machine.